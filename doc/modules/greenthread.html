
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>greenthread – Green Thread Implementation &#8212; Eventlet 0.28.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pools - Generic pools of resources" href="pools.html" />
    <link rel="prev" title="greenpool – Green Thread Pools" href="greenpool.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pools.html" title="pools - Generic pools of resources"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="greenpool.html" title="greenpool – Green Thread Pools"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Eventlet 0.28.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules.html" accesskey="U">Module Reference</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-eventlet.greenthread">
<span id="greenthread-green-thread-implementation"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">greenthread</span></code> – Green Thread Implementation<a class="headerlink" href="#module-eventlet.greenthread" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="eventlet.greenthread.sleep">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">sleep</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seconds</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield control to another eligible coroutine until at least <em>seconds</em> have
elapsed.</p>
<p><em>seconds</em> may be specified as an integer, or a float if fractional seconds
are desired. Calling <code class="xref py py-func docutils literal notranslate"><span class="pre">sleep()</span></code> with <em>seconds</em> of 0 is the
canonical way of expressing a cooperative yield. For example, if one is
looping over a large list performing an expensive calculation without
calling any socket methods, it’s a good idea to call <code class="docutils literal notranslate"><span class="pre">sleep(0)</span></code>
occasionally; otherwise nothing else will run.</p>
</dd></dl>

<dl class="py function">
<dt id="eventlet.greenthread.spawn">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">spawn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.spawn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a greenthread to run <code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>.  Returns a
<a class="reference internal" href="#eventlet.greenthread.GreenThread" title="eventlet.greenthread.GreenThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreenThread</span></code></a> object which you can use to get the results of the
call.</p>
<p>Execution control returns immediately to the caller; the created greenthread
is merely scheduled to be run at the next available opportunity.
Use <a class="reference internal" href="#eventlet.greenthread.spawn_after" title="eventlet.greenthread.spawn_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_after()</span></code></a> to  arrange for greenthreads to be spawned
after a finite delay.</p>
</dd></dl>

<dl class="py function">
<dt id="eventlet.greenthread.spawn_n">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">spawn_n</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.spawn_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#eventlet.greenthread.spawn" title="eventlet.greenthread.spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn()</span></code></a>, but returns a <code class="docutils literal notranslate"><span class="pre">greenlet</span></code> object from
which it is not possible to retrieve either a return value or
whether it raised any exceptions.  This is faster than
<a class="reference internal" href="#eventlet.greenthread.spawn" title="eventlet.greenthread.spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn()</span></code></a>; it is fastest if there are no keyword arguments.</p>
<p>If an exception is raised in the function, spawn_n prints a stack
trace; the print can be disabled by calling
<a class="reference internal" href="debug.html#eventlet.debug.hub_exceptions" title="eventlet.debug.hub_exceptions"><code class="xref py py-func docutils literal notranslate"><span class="pre">eventlet.debug.hub_exceptions()</span></code></a> with False.</p>
</dd></dl>

<dl class="py function">
<dt id="eventlet.greenthread.kill">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">kill</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">throw_args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates the target greenthread by raising an exception into it.
Whatever that greenthread might be doing; be it waiting for I/O or another
primitive, it sees an exception right away.</p>
<p>By default, this exception is GreenletExit, but a specific exception
may be specified.  <em>throw_args</em> should be the same as the arguments to
raise; either an exception instance or an exc_info tuple.</p>
<p>Calling <a class="reference internal" href="#eventlet.greenthread.kill" title="eventlet.greenthread.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">kill()</span></code></a> causes the calling greenthread to cooperatively yield.</p>
</dd></dl>

<dl class="py function">
<dt id="eventlet.greenthread.spawn_after">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">spawn_after</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seconds</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.spawn_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawns <em>func</em> after <em>seconds</em> have elapsed.  It runs as scheduled even if
the current greenthread has completed.</p>
<p><em>seconds</em> may be specified as an integer, or a float if fractional seconds
are desired. The <em>func</em> will be called with the given <em>args</em> and
keyword arguments <em>kwargs</em>, and will be executed within its own greenthread.</p>
<p>The return value of <a class="reference internal" href="#eventlet.greenthread.spawn_after" title="eventlet.greenthread.spawn_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_after()</span></code></a> is a <a class="reference internal" href="#eventlet.greenthread.GreenThread" title="eventlet.greenthread.GreenThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreenThread</span></code></a> object,
which can be used to retrieve the results of the call.</p>
<p>To cancel the spawn and prevent <em>func</em> from being called,
call <a class="reference internal" href="#eventlet.greenthread.GreenThread.cancel" title="eventlet.greenthread.GreenThread.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreenThread.cancel()</span></code></a> on the return value of <a class="reference internal" href="#eventlet.greenthread.spawn_after" title="eventlet.greenthread.spawn_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_after()</span></code></a>.
This will not abort the function if it’s already started running, which is
generally the desired behavior.  If terminating <em>func</em> regardless of whether
it’s started or not is the desired behavior, call <a class="reference internal" href="#eventlet.greenthread.GreenThread.kill" title="eventlet.greenthread.GreenThread.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreenThread.kill()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="eventlet.greenthread.spawn_after_local">
<code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">spawn_after_local</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seconds</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.spawn_after_local" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawns <em>func</em> after <em>seconds</em> have elapsed.  The function will NOT be
called if the current greenthread has exited.</p>
<p><em>seconds</em> may be specified as an integer, or a float if fractional seconds
are desired. The <em>func</em> will be called with the given <em>args</em> and
keyword arguments <em>kwargs</em>, and will be executed within its own greenthread.</p>
<p>The return value of <a class="reference internal" href="#eventlet.greenthread.spawn_after" title="eventlet.greenthread.spawn_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_after()</span></code></a> is a <a class="reference internal" href="#eventlet.greenthread.GreenThread" title="eventlet.greenthread.GreenThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreenThread</span></code></a> object,
which can be used to retrieve the results of the call.</p>
<p>To cancel the spawn and prevent <em>func</em> from being called,
call <a class="reference internal" href="#eventlet.greenthread.GreenThread.cancel" title="eventlet.greenthread.GreenThread.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreenThread.cancel()</span></code></a> on the return value. This will not abort the
function if it’s already started running.  If terminating <em>func</em> regardless
of whether it’s started or not is the desired behavior, call
<a class="reference internal" href="#eventlet.greenthread.GreenThread.kill" title="eventlet.greenthread.GreenThread.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreenThread.kill()</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="eventlet.greenthread.GreenThread">
<em class="property">class </em><code class="sig-prename descclassname">eventlet.greenthread.</code><code class="sig-name descname">GreenThread</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread" title="Permalink to this definition">¶</a></dt>
<dd><p>The GreenThread class is a type of Greenlet which has the additional
property of being able to retrieve the return value of the main function.
Do not construct GreenThread objects directly; call <a class="reference internal" href="#eventlet.greenthread.spawn" title="eventlet.greenthread.spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn()</span></code></a> to get one.</p>
<dl class="py method">
<dt id="eventlet.greenthread.GreenThread.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">throw_args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kills the greenthread using <a class="reference internal" href="#eventlet.greenthread.kill" title="eventlet.greenthread.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">kill()</span></code></a>, but only if it hasn’t
already started running.  After being canceled,
all calls to <a class="reference internal" href="#eventlet.greenthread.GreenThread.wait" title="eventlet.greenthread.GreenThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> will raise <em>throw_args</em> (which default
to <code class="xref py py-class docutils literal notranslate"><span class="pre">greenlet.GreenletExit</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="eventlet.greenthread.GreenThread.kill">
<code class="sig-name descname">kill</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">throw_args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread.kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Kills the greenthread using <a class="reference internal" href="#eventlet.greenthread.kill" title="eventlet.greenthread.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">kill()</span></code></a>.  After being killed
all calls to <a class="reference internal" href="#eventlet.greenthread.GreenThread.wait" title="eventlet.greenthread.GreenThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> will raise <em>throw_args</em> (which default
to <code class="xref py py-class docutils literal notranslate"><span class="pre">greenlet.GreenletExit</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="eventlet.greenthread.GreenThread.link">
<code class="sig-name descname">link</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">curried_args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">curried_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up a function to be called with the results of the GreenThread.</p>
<p>The function must have the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="p">[</span><span class="n">curried</span> <span class="n">args</span><span class="o">/</span><span class="n">kwargs</span><span class="p">]):</span>
</pre></div>
</div>
<p>When the GreenThread finishes its run, it calls <em>func</em> with itself
and with the <a class="reference external" href="http://en.wikipedia.org/wiki/Currying">curried arguments</a> supplied
at link-time.  If the function wants to retrieve the result of the GreenThread,
it should call wait() on its first argument.</p>
<p>Note that <em>func</em> is called within execution context of
the GreenThread, so it is possible to interfere with other linked
functions by doing things like switching explicitly to another
greenthread.</p>
</dd></dl>

<dl class="py method">
<dt id="eventlet.greenthread.GreenThread.unlink">
<code class="sig-name descname">unlink</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">curried_args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">curried_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread.unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove linked function set by <a class="reference internal" href="#eventlet.greenthread.GreenThread.link" title="eventlet.greenthread.GreenThread.link"><code class="xref py py-meth docutils literal notranslate"><span class="pre">link()</span></code></a></p>
<p>Remove successfully return True, otherwise False</p>
</dd></dl>

<dl class="py method">
<dt id="eventlet.greenthread.GreenThread.wait">
<code class="sig-name descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#eventlet.greenthread.GreenThread.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of the main function of this GreenThread.  If the
result is a normal return value, <a class="reference internal" href="#eventlet.greenthread.GreenThread.wait" title="eventlet.greenthread.GreenThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> returns it.  If it raised
an exception, <a class="reference internal" href="#eventlet.greenthread.GreenThread.wait" title="eventlet.greenthread.GreenThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> will raise the same exception (though the
stack trace will unavoidably contain some frames from within the
greenthread module).</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="greenpool.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">greenpool</span></code> – Green Thread Pools</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pools.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pools</span></code> - Generic pools of resources</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/greenthread.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pools.html" title="pools - Generic pools of resources"
             >next</a> |</li>
        <li class="right" >
          <a href="greenpool.html" title="greenpool – Green Thread Pools"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Eventlet 0.28.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules.html" >Module Reference</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2005-2010, Eventlet Contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0.
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42952223-1', 'eventlet.net');
  ga('send', 'pageview');
</script>

  </body>
</html>